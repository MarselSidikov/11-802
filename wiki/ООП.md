# Процедурный подход

* Программа = алгоритм + структура данных

Рассмотрим пример моделирования некоторой предметной области с помощью процедурного подхода в языке С

* Понятие struct - пользовательский тип данных, представляющий собой набор разнотипных переменных

```C
struct Human {
	int age;
	char name[30];
	double height;
};
```

* Есть возможность объявлять экземпляры этого типа

```C
Human marsel;
strcpy(marsel.name, "Marsel Sidikov");
marsel.age = 24;
marsel.height = 1.85;
```

* Что, если Марсель может расти?

```C
void grow(Human &human) {
	human.height += 0.1;
}
```

Получается, что Марсель будет расти следующим образом:

```C
grow(marsel);
```

## Проблемы подобного подхода:

1) Проблемы с моделированием предмтеной области - почему рост вызывается над Марселем, а не Марсель растет?
2) Проблемы с контролем корректности состояния объекта:

```C
marsel.age = -10;
```
3) Проблема поддержки кода, который состоит из "процедур, которые вызывают другие процедуры" - спагетти.

## ООП

* Парадигма программирования - способ организации вычислений внутри программы + тип мышления программиста, разрабатывающего программу.

* ООП - парадигма программирования, основными понятиями которой являются понятия класса и объекта.

* Тип данных - множество возможных значений и множество операций над этими значениями. 

Например, int - множество целых чисел, с операциями +-*/%.

* Абстракция - набор ЗНАЧИМЫХ обобщающих характеристик некоторых объектов, в контексте какой-либо задачи.

* Класс - абстрактный тип данных - такой пользовательский тип данных, который был получен методом абстракции. (некоторый шаблон).

* Объект - экземпляр класса, обладающий определенным состоянием и поведением.

### Пример класса на языке программирования Java

```JAVA
class Human {
	// поля (fields) - некоторые переменные, 
	// объявленные внутри класса
	// конкретные значения переменных задают
	// состояние объекта
	String name;
	int age;
	double height;

	// метод - функции и процедуры, определенные внутри класса
	// они задают поведение объектов
	// вызываются непосредственно из объекта
	void grow() {
		height += 0.1; 
	}

	void hit(Human other) {
		other.height -= 0.1;
	}
}
```

* Пример использования класса Human

```JAVA
class Program {
	public static void main(String args[]) {
		// объектная переменная
		// ячейка памяти, которая будет указывать
		// на другую область памяти, где находится
		// объект непосредственно
		Human marsel;

		// создания экземпляра класса (то есть объекта, инстанса)
		marsel = new Human();

		// задаю полям конкретные значения
		marsel.age = 24;
		marsel.name = "Марсель Сидиков";
		marsel.height = 1.85;

		// вызов метода
		marsel.grow();

		Human student = new Human();
		student.age = 17;
		student.height = 1.82;
		student.name = "Не Марк 2001";

		student.hit(marsel);
	}
}
```

* Программа в ООП - объекты, посылающие сообщения друг другу.

### Программисты и ООП

* Программисты делятся на две категории (при этом можно быть одновременно в двух) - пользователи классов (создают объекты) и разработчики классов (описывают классы).

## Решение проблемы с обеспечением корректного состояния объекта

* Доступ к членам класса (к полям и методам)

* Уровень доступа - доступность члена класса вне этого класса

* Модификатор доступа - некоторое ключевое слово, которое обеспечивает определенный уровень доступа

* private(приватный) - обеспечивает закрытый уровень доступа, член класса не доступен вне этого класса.

* public(публичный) - обеспечивает открытый уровень доступа, член класса доступен в любом месте вне этого класса.

* отсутствие модификатора указывает на package-private уровень доступа (член класса доступен внутри пакета).

### Пример организации доступа в Java

```JAVA
class Human {
	private String name;
	private int age;
	private double height;

	public void grow() {
		height += 0.1; 
	}

	public void hit(Human other) {
		other.height -= 0.1;
	}
} 
```

* Возникает проблема, как задать необходимые значения полям класса?

```JAVA
Human marsel = new Human();
marsel.name = "Марсель Сидиков"; // не скомпилируется, потому что поле закрыто
```

* Решение - методы доступа

Методы доступа позволяют обеспечить контролируемый доступ к полям класса. При этом это не синтаксическая конструкция Java, а правила описания таких методов.

* Setters - сеттеры, методы, позволяющие задать значения.
* Getters - геттеры, методы, позволяющие получить значения. 

* this - объектная переменная, которая содержит ссылку на объект, внутри которог проиходит вызов метода.

```JAVA
class Human {
	private String name;
	private int age;
	private double height;

	public void setName(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setAge(int age) {
		if (age >= 0) {
			this.age = age;
		} else this.age = 0;
	}

	public int getAge() {
		return age;
	}


	public void grow() {
		height += 0.1; 
	}

	public void hit(Human other) {
		other.height -= 0.1;
	}
} 
```

* Тогда в main

```JAVA
Human marsel = new Human();
marsel.age = -10; // нельзя, нет доступа, потому что private
marsel.setAge(-10); // marsel.age ~ 0
System.out.println(marsel.getAge());
int marselAge = marsel.getAge();
```

## Проблема инициализации объекта

* Инициализация - процесс задания начальных значений созданному объекту.

* Создание экземпляра - ключевое слово new.

* Инициализацию выполняет конструктор ~ new Human();

* По умолчанию, в каждом классе есть конструктор без параметров, который задает нулевые значения для полей:


- int = 0
- double = 0.0
- boolean = false
- String = ""
- char = '\0'

* Конструктор можно переопределить

```JAVA
class Human {
	private String name;
	private int age;
	private double height;

	public Human() {
		this.name = "DEFAULT_NAME";
		this.age = 1;
		this.height = 1.0;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setAge(int age) {
		if (age >= 0) {
			this.age = age;
		} else this.age = 0;
	}

	public int getAge() {
		return age;
	}


	public void grow() {
		height += 0.1; 
	}

	public void hit(Human other) {
		other.height -= 0.1;
	}
} 
```

* Теперь при создании объекта он будет иметь определенные значения:

```JAVA
Human human = new Human();
System.out.println(human.getName()); // DEFAULT_NAME
```

* Конструктор - набор инструкций, выполняющий инициализацю объекта (формирование начального состояния). НЕ МЕТОД, НЕ ФУНКЦИЯ И НЕ ПРОЦЕДУРА

* Можно определить свой конструктор с параметрами (тогда, конструктор по умолчанию не будет доступен).

```JAVA
class Human {
	private String name;
	private int age;
	private double height;

	public Human() {
		this.name = "DEFAULT_NAME";
		this.age = 1;
		this.height = 1.0;
	}

	public Human(String name, int age, double height) {
		this.setName(name);
		this.setAge(age);
		this.setHeight(height);
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setAge(int age) {
		if (age >= 0) {
			this.age = age;
		} else this.age = 0;
	}

	public int getAge() {
		return age;
	}


	public void grow() {
		height += 0.1; 
	}

	public void hit(Human other) {
		other.height -= 0.1;
	}
} 
```

* Тогда можно использовать оба конструктора:

```JAVA
Human human = new Human();
Human marsel = new Human("Марсель Сидиков", 24, 1.85);
```

### Итоги:

* Члены класса:

- поля
- конструкторы
- методы доступа
- методы

## Статические члены класса 

* Некоторые члены класса относятся к области видимости не объектов, а классов.
* Такие члены класса являются глобальными по отношению ко всем объектам данного класса.

* Данные члены калсса помечаются модификатором static.

### Статические поля

* Представляют собой глобальные переменные.

* Инициализация таких переменных возможна в статическом инициализаторе.

* Статические переменые с точки зрения ООП могут быть использованы для моделирования
максимально общих элементов предметной области. Например - для хранения глобального состояния.

```JAVA
class Human {
    public static int maxAge = 100;
}
```

### Статические методы

* Метод, вызов которого возможен непосредтсвенно из класса, без создания объекта
* Статический метод с точки зрения ООП используется для моделирования глобального ВНЕОБЪЕКТНОГО поведения.
Например - операция сложения в предметной области "Математика".
* Статический метод может обращаться только с статическим полям класса.